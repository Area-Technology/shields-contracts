{
  "language": "Solidity",
  "sources": {
    "contracts/HardwareGenerator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport './interfaces/IHardwareGenerator.sol';\nimport './interfaces/IHardwareSVGs.sol';\nimport '@openzeppelin/contracts/utils/Strings.sol';\n\n/// @dev Generate Shield SVG\ncontract HardwareGenerator is IHardwareGenerator {\n    using Strings for uint16;\n\n    IHardwareSVGs immutable hardwareSVGs1;\n    IHardwareSVGs immutable hardwareSVGs2;\n    IHardwareSVGs immutable hardwareSVGs3;\n    IHardwareSVGs immutable hardwareSVGs4;\n    IHardwareSVGs immutable hardwareSVGs5;\n    IHardwareSVGs immutable hardwareSVGs6;\n    IHardwareSVGs immutable hardwareSVGs7;\n    IHardwareSVGs immutable hardwareSVGs8;\n    IHardwareSVGs immutable hardwareSVGs9;\n    IHardwareSVGs immutable hardwareSVGs10;\n    IHardwareSVGs immutable hardwareSVGs11;\n    IHardwareSVGs immutable hardwareSVGs12;\n    IHardwareSVGs immutable hardwareSVGs13;\n    IHardwareSVGs immutable hardwareSVGs14;\n    IHardwareSVGs immutable hardwareSVGs15;\n    IHardwareSVGs immutable hardwareSVGs16;\n    IHardwareSVGs immutable hardwareSVGs17;\n    IHardwareSVGs immutable hardwareSVGs18;\n    IHardwareSVGs immutable hardwareSVGs19;\n    IHardwareSVGs immutable hardwareSVGs20;\n    IHardwareSVGs immutable hardwareSVGs21;\n    IHardwareSVGs immutable hardwareSVGs22;\n    IHardwareSVGs immutable hardwareSVGs23;\n    IHardwareSVGs immutable hardwareSVGs24;\n    IHardwareSVGs immutable hardwareSVGs25;\n    IHardwareSVGs immutable hardwareSVGs26;\n    IHardwareSVGs immutable hardwareSVGs27;\n    IHardwareSVGs immutable hardwareSVGs28;\n    IHardwareSVGs immutable hardwareSVGs29;\n    IHardwareSVGs immutable hardwareSVGs30;\n    IHardwareSVGs immutable hardwareSVGs31;\n    IHardwareSVGs immutable hardwareSVGs32;\n    IHardwareSVGs immutable hardwareSVGs33;\n    IHardwareSVGs immutable hardwareSVGs34;\n    IHardwareSVGs immutable hardwareSVGs35;\n    IHardwareSVGs immutable hardwareSVGs36;\n    IHardwareSVGs immutable hardwareSVGs37;\n    IHardwareSVGs immutable hardwareSVGs38;\n\n    constructor(HardwareSVGs memory svgs) {\n        hardwareSVGs1 = svgs.hardwareSVGs1;\n        hardwareSVGs2 = svgs.hardwareSVGs2;\n        hardwareSVGs3 = svgs.hardwareSVGs3;\n        hardwareSVGs4 = svgs.hardwareSVGs4;\n        hardwareSVGs5 = svgs.hardwareSVGs5;\n        hardwareSVGs6 = svgs.hardwareSVGs6;\n        hardwareSVGs7 = svgs.hardwareSVGs7;\n        hardwareSVGs8 = svgs.hardwareSVGs8;\n        hardwareSVGs9 = svgs.hardwareSVGs9;\n        hardwareSVGs10 = svgs.hardwareSVGs10;\n        hardwareSVGs11 = svgs.hardwareSVGs11;\n        hardwareSVGs12 = svgs.hardwareSVGs12;\n        hardwareSVGs13 = svgs.hardwareSVGs13;\n        hardwareSVGs14 = svgs.hardwareSVGs14;\n        hardwareSVGs15 = svgs.hardwareSVGs15;\n        hardwareSVGs16 = svgs.hardwareSVGs16;\n        hardwareSVGs17 = svgs.hardwareSVGs17;\n        hardwareSVGs18 = svgs.hardwareSVGs18;\n        hardwareSVGs19 = svgs.hardwareSVGs19;\n        hardwareSVGs20 = svgs.hardwareSVGs20;\n        hardwareSVGs21 = svgs.hardwareSVGs21;\n        hardwareSVGs22 = svgs.hardwareSVGs22;\n        hardwareSVGs23 = svgs.hardwareSVGs23;\n        hardwareSVGs24 = svgs.hardwareSVGs24;\n        hardwareSVGs25 = svgs.hardwareSVGs25;\n        hardwareSVGs26 = svgs.hardwareSVGs26;\n        hardwareSVGs27 = svgs.hardwareSVGs27;\n        hardwareSVGs28 = svgs.hardwareSVGs28;\n        hardwareSVGs29 = svgs.hardwareSVGs29;\n        hardwareSVGs30 = svgs.hardwareSVGs30;\n        hardwareSVGs31 = svgs.hardwareSVGs31;\n        hardwareSVGs32 = svgs.hardwareSVGs32;\n        hardwareSVGs33 = svgs.hardwareSVGs33;\n        hardwareSVGs34 = svgs.hardwareSVGs34;\n        hardwareSVGs35 = svgs.hardwareSVGs35;\n        hardwareSVGs36 = svgs.hardwareSVGs36;\n        hardwareSVGs37 = svgs.hardwareSVGs37;\n        hardwareSVGs38 = svgs.hardwareSVGs38;\n    }\n\n    function callHardwareSVGs(IHardwareSVGs target, uint16 hardware)\n        internal\n        view\n        returns (IHardwareSVGs.HardwareData memory)\n    {\n        bytes memory functionSelector = abi.encodePacked('hardware_', uint16(hardware).toString(), '()');\n\n        bool success;\n        bytes memory result;\n        (success, result) = address(target).staticcall(abi.encodeWithSelector(bytes4(keccak256(functionSelector))));\n\n        return abi.decode(result, (IHardwareSVGs.HardwareData));\n    }\n\n    function generateHardware(uint16 hardware) external view override returns (IHardwareSVGs.HardwareData memory) {\n        if (hardware <= 5) {\n            return callHardwareSVGs(hardwareSVGs1, hardware);\n        }\n\n        if (hardware <= 9) {\n            return callHardwareSVGs(hardwareSVGs2, hardware);\n        }\n\n        if (hardware <= 14) {\n            return callHardwareSVGs(hardwareSVGs3, hardware);\n        }\n\n        if (hardware <= 18) {\n            return callHardwareSVGs(hardwareSVGs4, hardware);\n        }\n\n        if (hardware <= 22) {\n            return callHardwareSVGs(hardwareSVGs5, hardware);\n        }\n\n        if (hardware <= 25) {\n            return callHardwareSVGs(hardwareSVGs6, hardware);\n        }\n\n        if (hardware <= 29) {\n            return callHardwareSVGs(hardwareSVGs7, hardware);\n        }\n\n        if (hardware <= 33) {\n            return callHardwareSVGs(hardwareSVGs8, hardware);\n        }\n\n        if (hardware <= 37) {\n            return callHardwareSVGs(hardwareSVGs9, hardware);\n        }\n\n        if (hardware <= 41) {\n            return callHardwareSVGs(hardwareSVGs10, hardware);\n        }\n\n        if (hardware <= 44) {\n            return callHardwareSVGs(hardwareSVGs11, hardware);\n        }\n\n        if (hardware <= 47) {\n            return callHardwareSVGs(hardwareSVGs12, hardware);\n        }\n\n        if (hardware <= 51) {\n            return callHardwareSVGs(hardwareSVGs13, hardware);\n        }\n\n        if (hardware <= 56) {\n            return callHardwareSVGs(hardwareSVGs14, hardware);\n        }\n\n        if (hardware <= 60) {\n            return callHardwareSVGs(hardwareSVGs15, hardware);\n        }\n\n        if (hardware <= 63) {\n            return callHardwareSVGs(hardwareSVGs16, hardware);\n        }\n\n        if (hardware <= 68) {\n            return callHardwareSVGs(hardwareSVGs17, hardware);\n        }\n\n        if (hardware <= 72) {\n            return callHardwareSVGs(hardwareSVGs18, hardware);\n        }\n\n        if (hardware <= 75) {\n            return callHardwareSVGs(hardwareSVGs19, hardware);\n        }\n\n        if (hardware <= 77) {\n            return callHardwareSVGs(hardwareSVGs20, hardware);\n        }\n\n        if (hardware <= 79) {\n            return callHardwareSVGs(hardwareSVGs21, hardware);\n        }\n\n        if (hardware <= 82) {\n            return callHardwareSVGs(hardwareSVGs22, hardware);\n        }\n\n        if (hardware <= 84) {\n            return callHardwareSVGs(hardwareSVGs23, hardware);\n        }\n\n        if (hardware <= 86) {\n            return callHardwareSVGs(hardwareSVGs24, hardware);\n        }\n\n        if (hardware <= 88) {\n            return callHardwareSVGs(hardwareSVGs25, hardware);\n        }\n\n        if (hardware <= 90) {\n            return callHardwareSVGs(hardwareSVGs26, hardware);\n        }\n\n        if (hardware <= 92) {\n            return callHardwareSVGs(hardwareSVGs27, hardware);\n        }\n\n        if (hardware <= 95) {\n            return callHardwareSVGs(hardwareSVGs28, hardware);\n        }\n\n        if (hardware <= 97) {\n            return callHardwareSVGs(hardwareSVGs29, hardware);\n        }\n\n        if (hardware <= 99) {\n            return callHardwareSVGs(hardwareSVGs30, hardware);\n        }\n\n        if (hardware <= 101) {\n            return callHardwareSVGs(hardwareSVGs31, hardware);\n        }\n\n        if (hardware <= 103) {\n            return callHardwareSVGs(hardwareSVGs32, hardware);\n        }\n\n        if (hardware <= 106) {\n            return callHardwareSVGs(hardwareSVGs33, hardware);\n        }\n\n        if (hardware <= 111) {\n            return callHardwareSVGs(hardwareSVGs34, hardware);\n        }\n\n        if (hardware <= 113) {\n            return callHardwareSVGs(hardwareSVGs35, hardware);\n        }\n\n        if (hardware <= 115) {\n            return callHardwareSVGs(hardwareSVGs36, hardware);\n        }\n\n        if (hardware <= 117) {\n            return callHardwareSVGs(hardwareSVGs37, hardware);\n        }\n\n        if (hardware <= 120) {\n            return callHardwareSVGs(hardwareSVGs38, hardware);\n        }\n\n        revert('invalid hardware selection');\n    }\n}\n"
    },
    "contracts/interfaces/IHardwareGenerator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport './IHardwareSVGs.sol';\n\n/// @dev Generate Shield SVG\ninterface IHardwareGenerator {\n    /// @notice Generates hardware snippet of SVG\n    /// @param hardware uint representing hardware selection\n    /// @return HardwareData containing svg snippet and hardware title and hardware type\n    function generateHardware(uint16 hardware) external view returns (IHardwareSVGs.HardwareData memory);\n\n    struct HardwareSVGs {\n        IHardwareSVGs hardwareSVGs1;\n        IHardwareSVGs hardwareSVGs2;\n        IHardwareSVGs hardwareSVGs3;\n        IHardwareSVGs hardwareSVGs4;\n        IHardwareSVGs hardwareSVGs5;\n        IHardwareSVGs hardwareSVGs6;\n        IHardwareSVGs hardwareSVGs7;\n        IHardwareSVGs hardwareSVGs8;\n        IHardwareSVGs hardwareSVGs9;\n        IHardwareSVGs hardwareSVGs10;\n        IHardwareSVGs hardwareSVGs11;\n        IHardwareSVGs hardwareSVGs12;\n        IHardwareSVGs hardwareSVGs13;\n        IHardwareSVGs hardwareSVGs14;\n        IHardwareSVGs hardwareSVGs15;\n        IHardwareSVGs hardwareSVGs16;\n        IHardwareSVGs hardwareSVGs17;\n        IHardwareSVGs hardwareSVGs18;\n        IHardwareSVGs hardwareSVGs19;\n        IHardwareSVGs hardwareSVGs20;\n        IHardwareSVGs hardwareSVGs21;\n        IHardwareSVGs hardwareSVGs22;\n        IHardwareSVGs hardwareSVGs23;\n        IHardwareSVGs hardwareSVGs24;\n        IHardwareSVGs hardwareSVGs25;\n        IHardwareSVGs hardwareSVGs26;\n        IHardwareSVGs hardwareSVGs27;\n        IHardwareSVGs hardwareSVGs28;\n        IHardwareSVGs hardwareSVGs29;\n        IHardwareSVGs hardwareSVGs30;\n        IHardwareSVGs hardwareSVGs31;\n        IHardwareSVGs hardwareSVGs32;\n        IHardwareSVGs hardwareSVGs33;\n        IHardwareSVGs hardwareSVGs34;\n        IHardwareSVGs hardwareSVGs35;\n        IHardwareSVGs hardwareSVGs36;\n        IHardwareSVGs hardwareSVGs37;\n        IHardwareSVGs hardwareSVGs38;\n    }\n}\n"
    },
    "contracts/interfaces/IHardwareSVGs.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport './ICategories.sol';\n\ninterface IHardwareSVGs {\n    struct HardwareData {\n        string title;\n        ICategories.HardwareCategories hardwareType;\n        string svgString;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/interfaces/ICategories.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\n/// @dev Generate Shield SVG\ninterface ICategories {\n    enum FieldCategories {\n        MYTHIC,\n        HERALDIC\n    }\n\n    enum HardwareCategories {\n        STANDARD,\n        SPECIAL\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "metadata": {
      "bytecodeHash": "none"
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}