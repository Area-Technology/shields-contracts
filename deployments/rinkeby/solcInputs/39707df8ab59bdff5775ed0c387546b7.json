{
  "language": "Solidity",
  "sources": {
    "contracts/FieldGenerator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport './interfaces/IFieldGenerator.sol';\nimport './interfaces/IFieldSVGs.sol';\nimport '@openzeppelin/contracts/utils/Strings.sol';\n\n/// @dev Generate Field SVG\ncontract FieldGenerator is IFieldGenerator {\n    using Strings for uint16;\n\n    mapping(uint24 => Color) private _colors;\n\n    IFieldSVGs immutable fieldSVGs1;\n    IFieldSVGs immutable fieldSVGs2;\n    IFieldSVGs immutable fieldSVGs3;\n    IFieldSVGs immutable fieldSVGs4;\n    IFieldSVGs immutable fieldSVGs5;\n    IFieldSVGs immutable fieldSVGs6;\n    IFieldSVGs immutable fieldSVGs7;\n    IFieldSVGs immutable fieldSVGs8;\n    IFieldSVGs immutable fieldSVGs9;\n    IFieldSVGs immutable fieldSVGs10;\n    IFieldSVGs immutable fieldSVGs11;\n    IFieldSVGs immutable fieldSVGs12;\n    IFieldSVGs immutable fieldSVGs13;\n    IFieldSVGs immutable fieldSVGs14;\n    IFieldSVGs immutable fieldSVGs15;\n    IFieldSVGs immutable fieldSVGs16;\n    IFieldSVGs immutable fieldSVGs17;\n    IFieldSVGs immutable fieldSVGs18;\n    IFieldSVGs immutable fieldSVGs19;\n    IFieldSVGs immutable fieldSVGs20;\n    IFieldSVGs immutable fieldSVGs21;\n    IFieldSVGs immutable fieldSVGs22;\n    IFieldSVGs immutable fieldSVGs23;\n    IFieldSVGs immutable fieldSVGs24;\n\n    constructor(\n        uint24[] memory __colors,\n        string[] memory titles,\n        FieldSVGs memory svgs\n    ) {\n        require(__colors.length == titles.length, 'invalid array lengths');\n        for (uint256 i = 0; i < __colors.length; i++) {\n            require(__colors[i] != 0, 'FieldGenerator: colors cannot be 0');\n            _colors[__colors[i]] = Color({title: titles[i], exists: true});\n            emit ColorAdded(__colors[i], titles[i]);\n        }\n\n        fieldSVGs1 = svgs.fieldSVGs1;\n        fieldSVGs2 = svgs.fieldSVGs2;\n        fieldSVGs3 = svgs.fieldSVGs3;\n        fieldSVGs4 = svgs.fieldSVGs4;\n        fieldSVGs5 = svgs.fieldSVGs5;\n        fieldSVGs6 = svgs.fieldSVGs6;\n        fieldSVGs7 = svgs.fieldSVGs7;\n        fieldSVGs8 = svgs.fieldSVGs8;\n        fieldSVGs9 = svgs.fieldSVGs9;\n        fieldSVGs10 = svgs.fieldSVGs10;\n        fieldSVGs11 = svgs.fieldSVGs11;\n        fieldSVGs12 = svgs.fieldSVGs12;\n        fieldSVGs13 = svgs.fieldSVGs13;\n        fieldSVGs14 = svgs.fieldSVGs14;\n        fieldSVGs15 = svgs.fieldSVGs15;\n        fieldSVGs16 = svgs.fieldSVGs16;\n        fieldSVGs17 = svgs.fieldSVGs17;\n        fieldSVGs18 = svgs.fieldSVGs18;\n        fieldSVGs19 = svgs.fieldSVGs19;\n        fieldSVGs20 = svgs.fieldSVGs20;\n        fieldSVGs21 = svgs.fieldSVGs21;\n        fieldSVGs22 = svgs.fieldSVGs22;\n        fieldSVGs23 = svgs.fieldSVGs23;\n        fieldSVGs24 = svgs.fieldSVGs24;\n    }\n\n    function colorExists(uint24 color) public view override returns (bool) {\n        return _colors[color].exists;\n    }\n\n    function colorTitle(uint24 color) public view override returns (string memory) {\n        return _colors[color].title;\n    }\n\n    function callFieldSVGs(\n        IFieldSVGs target,\n        uint16 field,\n        uint24[4] memory colors\n    ) internal view returns (IFieldSVGs.FieldData memory) {\n        bytes memory functionSelector = abi.encodePacked('field_', uint16(field).toString(), '(uint24[4])');\n\n        bool success;\n        bytes memory result;\n        (success, result) = address(target).staticcall(\n            abi.encodeWithSelector(bytes4(keccak256(functionSelector)), colors)\n        );\n\n        return abi.decode(result, (IFieldSVGs.FieldData));\n    }\n\n    function generateField(uint16 field, uint24[4] memory colors)\n        external\n        view\n        override\n        returns (IFieldSVGs.FieldData memory)\n    {\n        if (field <= 27) {\n            return callFieldSVGs(fieldSVGs1, field, colors);\n        }\n\n        if (field <= 50) {\n            return callFieldSVGs(fieldSVGs2, field, colors);\n        }\n\n        if (field <= 66) {\n            return callFieldSVGs(fieldSVGs3, field, colors);\n        }\n\n        if (field <= 89) {\n            return callFieldSVGs(fieldSVGs4, field, colors);\n        }\n\n        if (field <= 110) {\n            return callFieldSVGs(fieldSVGs5, field, colors);\n        }\n\n        if (field <= 132) {\n            return callFieldSVGs(fieldSVGs6, field, colors);\n        }\n\n        if (field <= 150) {\n            return callFieldSVGs(fieldSVGs7, field, colors);\n        }\n\n        if (field <= 170) {\n            return callFieldSVGs(fieldSVGs8, field, colors);\n        }\n\n        if (field <= 177) {\n            return callFieldSVGs(fieldSVGs9, field, colors);\n        }\n\n        if (field <= 193) {\n            return callFieldSVGs(fieldSVGs10, field, colors);\n        }\n\n        if (field <= 198) {\n            return callFieldSVGs(fieldSVGs11, field, colors);\n        }\n\n        if (field <= 205) {\n            return callFieldSVGs(fieldSVGs12, field, colors);\n        }\n\n        if (field <= 211) {\n            return callFieldSVGs(fieldSVGs13, field, colors);\n        }\n\n        if (field <= 217) {\n            return callFieldSVGs(fieldSVGs14, field, colors);\n        }\n\n        if (field <= 223) {\n            return callFieldSVGs(fieldSVGs15, field, colors);\n        }\n\n        if (field <= 227) {\n            return callFieldSVGs(fieldSVGs16, field, colors);\n        }\n\n        if (field <= 233) {\n            return callFieldSVGs(fieldSVGs17, field, colors);\n        }\n\n        if (field <= 243) {\n            return callFieldSVGs(fieldSVGs18, field, colors);\n        }\n\n        if (field <= 262) {\n            return callFieldSVGs(fieldSVGs19, field, colors);\n        }\n\n        if (field <= 275) {\n            return callFieldSVGs(fieldSVGs20, field, colors);\n        }\n\n        if (field <= 284) {\n            return callFieldSVGs(fieldSVGs21, field, colors);\n        }\n\n        if (field <= 289) {\n            return callFieldSVGs(fieldSVGs22, field, colors);\n        }\n\n        if (field <= 298) {\n            return callFieldSVGs(fieldSVGs23, field, colors);\n        }\n\n        if (field == 299) {\n            return callFieldSVGs(fieldSVGs24, field, colors);\n        }\n\n        revert('invalid field selection');\n    }\n}\n"
    },
    "contracts/interfaces/IFieldGenerator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport './IFieldSVGs.sol';\nimport './IColors.sol';\n\n/// @dev Generate Field SVG\ninterface IFieldGenerator {\n    /// @notice Generates field snippet of SVG of the specified colors\n    /// @param field uint representing field selection\n    /// @param colors to be rendered in the field svg\n    /// @return FieldData containing svg snippet and field title\n    function generateField(uint16 field, uint24[4] memory colors) external view returns (IFieldSVGs.FieldData memory);\n\n    event ColorAdded(uint24 color, string title);\n\n    struct Color {\n        string title;\n        bool exists;\n    }\n\n    /// @notice Returns true if color exists in contract, else false.\n    /// @param color 3-byte uint representing color\n    /// @return true or false\n    function colorExists(uint24 color) external view returns (bool);\n\n    /// @notice Returns the title string corresponding to the 3-byte color\n    /// @param color 3-byte uint representing color\n    /// @return true or false\n    function colorTitle(uint24 color) external view returns (string memory);\n\n    struct FieldSVGs {\n        IFieldSVGs fieldSVGs1;\n        IFieldSVGs fieldSVGs2;\n        IFieldSVGs fieldSVGs3;\n        IFieldSVGs fieldSVGs4;\n        IFieldSVGs fieldSVGs5;\n        IFieldSVGs fieldSVGs6;\n        IFieldSVGs fieldSVGs7;\n        IFieldSVGs fieldSVGs8;\n        IFieldSVGs fieldSVGs9;\n        IFieldSVGs fieldSVGs10;\n        IFieldSVGs fieldSVGs11;\n        IFieldSVGs fieldSVGs12;\n        IFieldSVGs fieldSVGs13;\n        IFieldSVGs fieldSVGs14;\n        IFieldSVGs fieldSVGs15;\n        IFieldSVGs fieldSVGs16;\n        IFieldSVGs fieldSVGs17;\n        IFieldSVGs fieldSVGs18;\n        IFieldSVGs fieldSVGs19;\n        IFieldSVGs fieldSVGs20;\n        IFieldSVGs fieldSVGs21;\n        IFieldSVGs fieldSVGs22;\n        IFieldSVGs fieldSVGs23;\n        IFieldSVGs fieldSVGs24;\n    }\n}\n"
    },
    "contracts/interfaces/IFieldSVGs.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport './ICategories.sol';\n\n/// @dev Generate Field SVG\ninterface IFieldSVGs {\n    struct FieldData {\n        string title;\n        ICategories.FieldCategories fieldType;\n        string svgString;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/interfaces/IColors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\n/// @dev Generate Shield SVG\ninterface IColors {\n    event ColorAdded(uint24 color, string title);\n\n    struct Color {\n        string title;\n        bool exists;\n    }\n\n    /// @notice Returns true if color exists in contract, else false.\n    /// @param color 3-byte uint representing color\n    /// @return true or false\n    function colorExists(uint24 color) external view returns (bool);\n\n    /// @notice Returns the title string corresponding to the 3-byte color\n    /// @param color 3-byte uint representing color\n    /// @return true or false\n    function colorTitle(uint24 color) external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/ICategories.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\n/// @dev Generate Shield SVG\ninterface ICategories {\n    enum FieldCategories {\n        MYTHIC,\n        HERALDIC\n    }\n\n    enum HardwareCategories {\n        STANDARD,\n        SPECIAL\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}